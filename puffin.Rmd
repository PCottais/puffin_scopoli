---
title: "Scopoli’s shearwaters movements"
author: "Pierre Cottais & An Hoàng"
date: "15/12/2021"
output: 
  pdf_document: 
    extra_dependencies: ["float"]
    toc: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,
                      results = "hide")
```


```{r packages, include=FALSE}
library(tidyverse)
library(ggmap)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(lubridate)
library(wesanderson)
library(survival)
library(amt)
library(stargazer)
```

# Data exploration

## Generalisation data set

```{r include=FALSE}
# generalisation dataset
load("CALDIO_MPE_2021/generalisation datasets/grid_oceano_2011.Rdata")
load("CALDIO_MPE_2021/generalisation datasets/grid_oceano_Date_2011.Rdata")
```

```{r echo=FALSE, results='asis'}
grid_day1 <- grid_oceano[[1]]
tab_extract.grid <- rbind(head(grid_day1, 5), tail(grid_day1, 5))
stargazer(tab_extract.grid[, 1:7], type = "latex",
          title = "Extrait du jeu de données du 28 juin 2011*",
          notes = "*Six premières colonnes sur les 41 colonnes du jeu de données",
          summary = FALSE)
```

Grid giving tempretures and bathymetry data for each one of the `r length(grid_oceano)` days.


### Visualisation of the grid

```{r message=FALSE, warning=FALSE}
mediterranean  <- make_bbox(lat = Latitude, lon = Longitude, data = grid_day1)
map.day1 <- get_map(location = mediterranean) %>% ggmap()
map.day1 + geom_point(data = grid_day1, aes(x = Longitude, y = Latitude), size = 0.5)
```



## "Training" data set (Puffin's movements)

```{r include=FALSE}
# training dataset
load("CALDIO_MPE_2021/training datasets/CALDIO_2011_oceano.Rdata")
load("CALDIO_MPE_2021/training datasets/CALDIO_2012_oceano.Rdata")
```


```{r}
difftime(max(ALL2012$Time), min(ALL2011$Time), units = "days")
dates_2011 <- ALL2011$Time %>% date() %>% unique()
dates_2012 <- ALL2012$Time %>% date() %>% unique()
nb_days <- length(dates_2011) + length(dates_2012)
paste("Period #1: from", min(dates_2011), "to", max(dates_2011),
      "(", difftime(max(dates_2011), min(dates_2011)), "days )")
paste("Period #2: from", min(dates_2012), "to", max(dates_2012),
      "(", difftime(max(dates_2012), min(dates_2012)), "days )")
```


```{r eval=FALSE, include=FALSE}
cpt <- 0
for (day in 1:95) {
  if (grid_oceano[[day]]$Date[[1]] %in% dates_2011) {
    print(unique(grid_oceano[[day]]$Date))
    cpt <- cpt+1
  }
}
```


Les données de traçage sont récoltées sur `r nb_days` jours,
du `r date(min(ALL2011$Time))` au `r date(max(ALL2012$Time))`.

```{r echo=FALSE, results='asis'}
tab_extract.bird <- rbind(head(ALL2011, 5), tail(ALL2011, 5))
stargazer(tab_extract.bird[, 1:7], type = "latex",
          title = "Extrait du jeu de données*",
          notes = "*Dix premières colonnes sur les 25 colonnes du jeu de données",
          summary = FALSE)
```

Get the grid dataframe corresponding to the first observed day
```{r}
bool <- FALSE
i <- 0
while (!bool) {
  i <- i + 1
  if(grid_oceano[[i]]$Date[[1]] == dates_2011[1]) {
    bool <- TRUE
    grid_day1 <- grid_oceano[[i]]
  }
}

tab_extract.bird %>% 
  left_join(grid_day1, by = c("Longitude", "Latitude")) %>% 
  select(Site, Time, Date, ID, Longitude, Latitude, Bathy.x, Bathy.y)

```


### Data visualisation


Number of individuals (doesn't match with the "breeding pairs" of Clara's paper)
```{r eval=FALSE, include=FALSE}
ALL2011 %>% mutate(grep_ID = as.numeric(gsub("[A-Z]", "", ID))) %>% 
  dplyr::select(Site, trip_ID, ID, grep_ID) %>%
  group_by(Site) %>% 
  summarise(nb_breed = max(grep_ID))

ALL2012 %>% mutate(grep_ID = as.numeric(gsub("[A-Z]", "", ID))) %>% 
  dplyr::select(Site, trip_ID, ID, grep_ID) %>% 
  group_by(Site) %>% 
  summarise(nb_breed = max(grep_ID))
```


```{r}
bird1 <- ALL2011 %>% 
  # filter(!is.na(Site)) %>% 
  amt::select(x = Longitude, y = Latitude, t = Time, id = ID, Bathy = Bathy,
              SST1 = SST1) %>% 
  amt::filter(id == "ID1R")

track1 <- bird1 %>% 
  amt::make_track(.x = x, .y = y, .t = t, crs = "epsg:2154", bathy = Bathy,
                  sst1 = SST1, all_cols = FALSE)

summarize_sampling_rate(track1)

stps <- track1 %>% 
  amt::track_resample(rate = minutes(10), tolerance = seconds(60)) %>% 
  amt::filter_min_n_burst(min_n = 3) %>% 
  amt::steps_by_burst(keep_col = 'both') %>% 
  select(-c("burst__start", "burst__end"))  # removing these 2 auto created col.
  # amt::time_of_day(include.crepuscule = FALSE)
str(stps)

```


Get the grid dataframe corresponding to the observed day of stps dataframe
```{r}
# bool <- FALSE
# i <- 0
# while (!bool) {
#   i <- i + 1
#   if(grid_oceano[[i]]$Date[[1]] == date(stps$t1_)[1]) {
#     bool <- TRUE
#     grid_day1_bird1 <- grid_oceano[[i]]
#   }
# }
```

closest starting point to existing grid points
```{r}
# point1 <- stps[1, c("x2_", "y2_")]
# names(point1) <- c("Longitude", "Latitude")
# matrx <- grid_day1_bird1[, c("Longitude", "Latitude")] %>% as.matrix()
# nearest_pt <- Rfast::dista(point1, matrx, k = 1, index = TRUE)
# grid_day1_bird1[nearest_pt,]
# stps[1,]
```







adding random steps
```{r}
rdm_stps <- stps %>% 
  # replace(is.na(.), 0) %>% 
  amt::random_steps(n_control = 9) %>% 
  # amt::extract_covariates(wet) %>%
  # amt::time_of_day(include.crepuscule = FALSE) %>% 
  mutate(log_sl = log(sl_),
        burst_ = as.factor(burst_),
        step_id_ = as.factor(step_id_))

rdm_stps %>% 
  group_by(burst_) %>% 
  summarise(nb_stp = n())
```

```{r eval=FALSE, include=FALSE}
# stps_dates <- rdm_stps %>% select(t2_) %>% pull() %>% date()
# rdm_stps %>% filter(case_ == FALSE) %>% 
  # mutate(bathy_end = grid_oceano[which(grid_Oceano_Date %in% date(t2_))]
   
# for (i in 1:nrow(rdm_stps %>% filter(case_ == FALSE))){
#   point <- stps[i, c("x2_", "y2_")]
#   names(point) <- c("Longitude", "Latitude")
#   grid_day <- grid_oceano[[which(grid_Oceano_Date == date(rdm_stps$t2_[i]))]]
#   matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
#   nearest_point <- Rfast::dista(point, matrx, k = 1, index = TRUE)
#   rdm_stps[i, "bathy_end"] <- grid_day[nearest_pt, "Bathy"]
# }
# 
# nearest_pt <- Rfast::dista(point1, matrx, k = 1, index = TRUE)
# grid_day1_bird1[nearest_pt,]
# stps[1,]

# points <- rdm_stps %>% filter(case_ == FALSE) %>% 
#   select(x2_, y2_, t2_, bathy_end) %>% 
#   rename(Longitude= x2_, Latitude = y2_, Datetime = t2_)

# stps_dates <- unique(date(rdm_stps$t2_))
# bathy_days <- list(1:length(stps_dates))
# for (i in 1:length(stps_dates)) {
#   grid_day <- grid_oceano[[which(grid_Oceano_Date == stps_dates[i])]]
#   matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
#   points <- rdm_stps %>% 
#     filter(case_ == FALSE, date(t2_) == stps_dates[i]) %>% 
#     select(x2_, y2_,) %>% 
#     rename(Longitude = x2_, Latitude = y2_)
#   nearest_id <- Rfast::dista(points, matrx, k = 1, index = TRUE)
#   points$Bathy <- grid_day[nearest_id, "Bathy"]
# }

# get_habitat <- function(point){
#   long <- point$x2_
#   lat <- point$y2_
#   date <- date(point$t2_)
#   # get the grid data corresponding to the date
#   grid_day <- grid_oceano[[which(grid_Oceano_Date == date)]]
#   matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
#   
#   # match the bathy data to random steps bathy_end variable
#   point <- data.frame(long, lat)
#   nearest_id <- Rfast::dista(point, matrx, k = 1, index = TRUE)
#   return(grid_day[nearest_id,])
# }
# 
# points <- rdm_stps %>% 
#   filter(case_ == FALSE) %>% 
#   select(x2_, y2_, t2_)
# 
# res <- get_habitat(points[1:10,])


# get_habitat <- function(steps){
#   # df_points <- steps %>% select(x2_, y2_)
#   dates_stps <- unique(date(steps$t2_))
#   
#   # get the grids data corresponding to the dates and merge them
#   for (i in 1:length(dates_stps)){
#     grid_day <- grid_oceano[[which(grid_Oceano_Date == dates_stps[i])]]
#     matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
#   
#     # match the grid data to input steps
#     nearest_id <- Rfast::dista(steps[,c("x2_", "y2_")], matrx, k = 1, index = TRUE)
#     
#     grid_day[nearest_id,]
#   }
#   
#   
#   return(grid_days[,covariate])
# }
# 
# get_habitat(rdm_stps)


get_habitat_cov <- function(steps){
  for (i in 1:nrow(steps)){
    dates <- date(steps$t2_)
    if (steps[i, "case_"]==FALSE){
      grid_day <- grid_oceano[[which(grid_Oceano_Date == dates[i])]]
      matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
      nearest_id <- Rfast::dista(steps[i,c("x2_", "y2_")], matrx, k = 1, index = TRUE)
      # if (!is.na(grid_day[nearest_id, "Bathy"])){
        steps[i, "bathy_end"] <- grid_day[nearest_id, "Bathy"]
      # }
      # else{
      #   NA_Bathy <- NA_Bathy + 1
      # }
      # if (!is.na(grid_day[nearest_id, "SST1"])){
        steps[i, "temp_end"] <- grid_day[nearest_id, "SST1"]
      # }
      # else{
      #   NA_SST1 <- NA_SST1 + 1
      # }
    }
  }
  # return(list(NA_Bathy, NA_SST1, NA_logCHLA1))
  return(steps)
}



```


```{r}
get_habitat <- function(step, mutate_var = "bathy_end", covariate = "Bathy", output){
  # get 1 habitat covariate for a random ENDGING point (default Bathy)
  grid_day <- grid_oceano[[which(grid_Oceano_Date == date(step$t2_))]]
  matrx <- grid_day[, c("Longitude", "Latitude")] %>% as.matrix()
  nearest_id <- Rfast::dista(step[,c("x2_", "y2_")], matrx, k = 1, index = TRUE)
  step[, mutate_var] <- grid_day[nearest_id, covariate]
  return(step)
}
```


```{r eval=FALSE, include=FALSE}
# world %>% select(admin, income_grp, wikipedia, economy, geometry) %>% print(n=5)
# world$geometry[1]
# sf::st_crs(world)
# sea_medit <- ne_countries(scale = "medium", returnclass = "sf") %>% 
#   filter(name == "France") %>% 
#   st_crop(xmin = 4.5, xmax = 7, ymin = 39, ymax = 44)
# sea_medit %>% ggplot() + 
#   geom_sf() + 
#   geom_point(data = grid_day1_bird1[nearest_pt,],
#              aes(x = Longitude, y = Latitude),
#              size = 0.5) +
#   geom_point(data = stps[1,],
#              aes(x = x1_, y = y2_),
#              size = 0.8,
#              color = "red") + 
#   geom_point(data = grid_day1_bird1[nearest_pt[1],],
#              aes(x = Longitude, y = Latitude),
#              size = 0.5,
#              color = "orange")
```



```{r}
for (i in 1:nrow(rdm_stps)){
  if (rdm_stps[i, "case_"] == FALSE){
    rdm_stps[i,] <- get_habitat(rdm_stps[i,],
                                mutate_var = "bathy_end", covariate = "Bathy")
    rdm_stps[i,] <- get_habitat(rdm_stps[i,],
                                mutate_var = "temp_end", covariate = "SST1")
    rdm_stps[i,] <- get_habitat(rdm_stps[i,],
                                mutate_var = "logchla_end", covariate = "logCHLA1")
  }
}

rdm_stps[rdm_stps$case_==FALSE,]

```

amt::iSS function to run survival::clogit function usable in pipe workflow
```{r}
m1 <- rdm_stps %>% 
  amt::fit_issf(case_ ~ sl_ + ta_ + log_sl + strata(step_id_) +
                  + bathy_end + temp_end + logchla_end)  # covariates related to the habitat
m1$model
```










